package com.itsjamilahmed.spring.scs.demo.fraudcheck.ApiErrorHandlingService;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.stream.binder.BinderHeaders;
import org.springframework.context.annotation.Bean;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;

import java.util.function.Function;

@SpringBootApplication
public class ApiErrorHandlingServiceApplication {

	private static final Logger log = LoggerFactory.getLogger(ApiErrorHandlingServiceApplication.class);
	
	// Which message header keys store the PubSub+ broker inserted reply-to topic and correlation-IDs?
	static final String SOL_REPLYTO_DESTINATION_KEY = "solace_replyTo";
	static final String SOL_CORRELATION_ID_KEY = "solace_correlationId";

	// Which message header key stores the message timestamp?
	static final String SOL_MSG_TIMESTAMP_KEY = "timestamp";
	
	// Header keys to be used by the mediator service to store the values for pass-thru purposes to other services involved in the processing pipeline
	static final String MEDIATOR_REPLYTO_DESTINATION_KEY = "app_fraudCheckMediator_replyTo";
	static final String MEDIATOR_CORRELATION_ID_KEY = "app_fraudCheckMediator_correlationId";
	static final String MEDIATOR_MSG_TIMESTAMP_KEY = "app_fraudCheckMediator_timestamp";
	
	public static void main(String[] args) {
		SpringApplication.run(ApiErrorHandlingServiceApplication.class, args);
	}

	@Bean
	// Purpose: Generically receive error events that need to be routed back to the externally facing HTTP API
	//  * This service will receive an event that contains the error message as generated by any upstream service.
	//  * The event will also contain the reply-to topic and correlation ID to be used to route the response back to the open HTTP operation
	//  * that is awaiting a response via the PubSub+ Broker's Microgateway feature. 
	public Function<Message<String>, Message<String>> sendErrorResponse(){
		return input -> {
			
			String payload = input.getPayload();
			JSONObject jsonMessage;
			log.info("Received error message to process: " + input.getPayload());

			String outputTopic = "";		// Dynamically determined on a per-message basis
			String correlationID = "";		// Helps requesting applications correlate this reply to their outstanding response
			
			try {
				jsonMessage = (JSONObject) new JSONParser().parse(payload);
				jsonMessage.put("status", "error");
				
			} catch (ParseException e) {
				log.error("Did not receive a valid JSON formatted message for the error. " + e.toString());
				
				// Shouldn't really get here. The error message visible externally can be kept vague then.
				jsonMessage = new JSONObject();
				jsonMessage.put("errorMsg", "An unknown error occurred. Please retry the API call.");
			} 
			
			// May as well calculate the elapsed time between receiving the original request and this error event
			long errorMessageTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(SOL_MSG_TIMESTAMP_KEY, "0").toString());
			long originalRequestTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(MEDIATOR_MSG_TIMESTAMP_KEY, "0").toString());
			
			jsonMessage.put("elapsedTimeMs", errorMessageTimestampMs - originalRequestTimestampMs); 
			
			outputTopic = input.getHeaders().getOrDefault(MEDIATOR_REPLYTO_DESTINATION_KEY, "error/fallback/topic/here").toString();
			correlationID = input.getHeaders().getOrDefault(MEDIATOR_CORRELATION_ID_KEY, "").toString();
			
			// There is an external HTTP API call expected to be waiting for this response, with the reply-to topic known as well for the TARGET_DESTINATION header.
			// If this is missing to trigger an exception, something has gone very wrong...
			Message<String> output = MessageBuilder.withPayload(jsonMessage.toString())
					.setHeader(SOL_CORRELATION_ID_KEY, correlationID)
					.setHeader(BinderHeaders.TARGET_DESTINATION, outputTopic)
					.build();
			
			log.info("Sending timeout final reply message: " + output.getPayload() + " on topic: " + outputTopic + " with correlation-ID: " + correlationID);
			
			return output;
		};
	}
	
	@Bean
	// Purpose: Detect failure to process requests from the external API by the orchestrator service and handle the timeout
	//  * This service will see on its inbound queue the messages from the orchestrator's queue that TTL expired
	//  * (It's queue is essentially the dead-message-queue for the main queue)
	//  * This provides an opportunity to intercept this request and respond to the external API with a cancelled response
	//  * The API call can be retried and the caller may prefer a fast-fail versus a prolonged lack of response.
	public Function<Message<String>, Message<String>> sendTimeoutResponse(){
		return input -> {
			
			String payload = input.getPayload();
			JSONObject jsonMessage;
			log.info("Received timeout message to process: " + input.getPayload());
			
			String outputTopic = "";		// Dynamically determined on a per-message basis
			String correlationID = "";		// Helps requesting applications correlate this reply to their outstanding response
			
			jsonMessage = new JSONObject();
			jsonMessage.put("status", "error");
			jsonMessage.put("errorMsg", "This service is currently unavailable. Please try again later.");	

			
			// May as well calculate the elapsed time between receiving the original request and this error event
			long errorMessageTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(SOL_MSG_TIMESTAMP_KEY, "0").toString());
			long originalRequestTimestampMs = Long.parseLong(input.getHeaders().getOrDefault(MEDIATOR_MSG_TIMESTAMP_KEY, "0").toString());
			
			jsonMessage.put("elapsedTimeMs", errorMessageTimestampMs - originalRequestTimestampMs); 
			
			outputTopic = input.getHeaders().getOrDefault(MEDIATOR_REPLYTO_DESTINATION_KEY, "error/fallback/topic/here").toString();
			correlationID = input.getHeaders().getOrDefault(MEDIATOR_CORRELATION_ID_KEY, "").toString();
			
			// There is an external HTTP API call expected to be waiting for this response, with the reply-to topic known as well for the TARGET_DESTINATION header.
			// If this is missing to trigger an exception, something has gone very wrong...
			Message<String> output = MessageBuilder.withPayload(jsonMessage.toString())
					.setHeader(SOL_CORRELATION_ID_KEY, correlationID)
					.setHeader(BinderHeaders.TARGET_DESTINATION, outputTopic)
					.build();
			
			log.info("Sending timeout final reply message: " + output.getPayload() + " on topic: " + outputTopic + " with correlation-ID: " + correlationID);
			
			return output;
		};
	}
	
}
